Singleton:


Threads


Hashtable


-------------------------------------------------



Page:
- store every page in a sigle text file (FileWriter)
- filename: pageID
- file content: single line of text with all the information, for example separated by commata

- saves user data: log sequence number, user data

- saves log data:
- one text file containing one line for each log entry
- log entry: either consists of LSN, transaction ID, page ID and user data or of LSN, transaction ID and EOT (end of transaction)



Persistant Storage:




Persistance Manager
-------------------

- Singleton

- Accesses internal buffer and persistent storage


Internal buffer:
- Hashtable
- administers user data
- administers the correspondence between transactions and datasets
- persisting data of committed transactions, when there are more than five pages in the buffer (No-Force)
- check for a „full“ buffer after every write access
- refreshing pages in the buffer is possible
- no dirty pages are persisted (No-Steal)
- user data are overwritten directly (Non-Atomic)

- overview over ongoing and already completed transactions has to be maintained.
- may contain an arbitrary number of operations
- if the buffer􏰃 contains more than five datasets after a write operation, the persistence manager checks whether there are operations related to already committed transactions
- If there are such operations, then these operations are written directly to the persistent storage (non-atomic)
- Outdated datasets can reside in the persistent storage
- datasets of committed transactions that have not been written to the persistent storage can reside in the buffer􏰃
- dirty􏰂 datasets of uncommitted transactions cannot exist in the persistent storage (noforce, nosteal)


Persistent Storage:
- Files
- One filer per page


- noforce, nosteal, non-atomic
- undo recovery is not required after a system failure
- redo recovery is required

- allows concurrent requests from clients to user data
- performs deferred writes for modi􏰄ed data
- takes the necessary precautions for recovery after a system failure

- administers log data to keep track of modi􏰄cations that have not yet been persisted
- User data and log data have to be saved to a persistent storage

- accesses pages / text files (FileReader)



Logging:
- modifying operations are logged immediately
- support of crash recovery
- Log information have to be written to the persistent storage immediately and before the completion of a transaction, in particular, so that a recovery can be performed in the event of a system failure.

- physical state logging
- granulate: Page
- new states (after-images) of modified objects are written to the log file
- record types:
	- BOT and commit record
	- modification records (after-images)

- structure of log entries: [LSN, TAID, PageID, Redo]
- LSN: Log Sequence Number (monotonically ascending)
- TAID: transaction ID
- PageID: Page ID
- Redo: information required for redo



Functions:

beginTransaction():
- starts a new transaction
- creates a unique transaction ID and returns it to the client

commit(int taid):
- commits the transaction specified by the given transaction ID.

write(int taid, int pageid, String data):
- stored to internal buffer of persistance manager
- writes the given data with the given page ID on behalf of the given transaction to the bu􏰃ffer
- If the given page already exists, its content is replaced completely by the given data




Clients
-------

- 5 clients
- Each as single thread
- Several in parallel

- repeatedly execute transactions on the persistence manager
- write page: beginTransaction() write() write() ... commit()

- every operation is followed by a brief pause
- the number of writes in a transaction may vary

- Clients do not access the same pages: Client 1 accesses pages 10..19, Client 2 accesses pages 20..29 and so forth
- More than one page may be modi􏰄ed by one transaction
- The user data may consist of simple strings

- TAID is assigned by the persistence manager



Recovery Tool
-------------

- performs the analysis and redo phase of the crash recovery
- First, the so-called winner transactions have to be determined from the log data
- After that, the pending write operations have to be executed
- Remember updating the LSNs in the user data.





